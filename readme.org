#+title: nimtrs

Ast pattern matching, templating and rewriting. Supports regex-like
patterns for sequences. Is not tied to particular AST - ~NimNode~ is
supported, but not the *only* type of AST.

* Features

** Core concepts

*** ~Term~

Term is either of
- variable : ~$a~ or ~@a~
- constant : ~1, 3, 4~
- list : ~[t1, t2, t3, ...]~
- functor head + list of arguments (other terms) : ~f(t1, t2, t3 ...)~
- pattern ~*(12 | 13) & $a~

All of the functions and types in the library have to generic
parameters: ~V~ and ~F~. First one is a type of constants (values),
second one type of a functor.

# NOTE mathematical expressions are a good example for actually
# rewriting things

# ~sin($a + $b)~ can be rewritten into  = (sin($a) * cos($b)) + (cos($a) * sin($b))~

- If you want to model mathematical expressions ~F~ would be a string
  and ~V~ in integer type. Possible example of a functor: ~cos(0.2)~
  or ~sin($a + $b)~. Note: ~+~ is also a functor - binary operator is
  just a 2-ary function.
- For working with nim ast functor head is a ~NimNodeKind~ and
  constant is a ~NimNode~. For example for expression like ~3 + 3~ we
  get ast dump (in lisp form) that looks like this. ~Infix~ is a
  functor head, ~(Ident "+")~ is a *constant* since it is *not
  possible* for it to have arguments.
  #+begin_src lisp
    (Infix (Ident "+") (IntLit 3) (IntLit 3))
  #+end_src

*** ~TermImpl~

Terms are build as /heterogenous/ representation for trees - there is
only single type for functor head, but since constants themself can
differ (~(IntLit 3)~ and ~(Ident "+")~) it is necessary to distinguish
between them somehow.

One possible soltion is to take OOP-style approach and model term as a
object hierarchy, with each one implementing some kind of ~isConstant~
and ~getFunctorSymbol~ methods. This library uses somewhat similar
approach, but more suitable for nim case objects.

#+caption: TermImpl for nim node
#+begin_src nim
  func isFunctor*(nnk: NimNodeKind): bool =
    nnk notin { # set of node kinds that cannot be considered 'functor'.
                # I.e. it is not possible to have a child for
                # `nnkFloatLit` for example, therefore it is not a
                # functor.
      nnkNone, nnkEmpty, nnkNilLit, # Empty node
      nnkCharLit..nnkUInt64Lit, # Int literal
      nnkFloatLit..nnkFloat64Lit, # Float literal
      nnkStrLit..nnkTripleStrLit, nnkCommentStmt, nnkIdent, nnkSym # Str lit
    }

  const nimAstImpl* = TermImpl[NimNode, NimNodeKind](
    getsym: ( # Get functor symbol from value. `V -> F`
      proc(n: NimNode): NimNodeKind = n.kind
    ),
    isFunctorSym: ( # Check if functor is a symbol. `F -> bool`
      proc(kind: NimNodeKind): bool = kind.isFunctor()
    ),
    makeFunctor: ( # Construct functor from head symbol and list of
                   # arguments. `F x seq[V] -> V`
      proc(op: NimNodeKind, sub: seq[NimNode]): NimNode =
        if sub.len == 0: newNimNode(op)
        else: newTree(op, sub)
    ),
    getArguments: ( # Get list of arguments from term. No checking is
                    # necessary - only functor terms would be queried
                    # for arguments. `V -> seq[V]`
      proc(n: NimNode): seq[NimNode] = toSeq(n.children)
    ),
    valStrGen: ( # Generate string representation for term. Used for
                 # pretty-printing terms. `V -> string`
      proc(n: NimNode): string = n.toStrLit().strVal()
    ),
  )
#+end_src

This 'implementation' is passed to ~toTerm~ and ~fromTerm~ converters
to convert value of type ~V~ to ~Term[V, F]~.

*** Variables

*** Environment

*** Unification

** Pattern matching

#+begin_src nim
  import nimtrs/[trscore, trspprint, trsdsl, nimast_trs]
  import options

  template matchPatternNim(term: NodeTerm, patt: untyped): untyped =
    matchPattern(term, nimAstImpl, patt)

  macro ifTest(body: untyped): untyped =
    for stmt in body:
      let term = stmt.toTerm(nimAstImpl)
      #                      ^^^^^^^^^^
      #                      'Implementation' - used for converting
      #                       value of type `V` to term.
      if term.matchPatternNim(
      # Match head of the `term`
      # |      Match pattern one or more times
      # |      |Match `nnkElifBrach` - `nnk` prefix might be omiited
      # |      ||  Concatenation of two parts Optional artument in the term
      # v_____ vv_________                  v v
        IfStmt(*ElifBranch(@conds, @bodies) & ?Else($elsebody))):
        #      A           ^       ^      A         ^^^^^^^^^
        #      !           |_______|      !         Possible nullable variable,
        #      !           |              !         inserted as `seq[F]`
        #      !           |              !
        #      !           Two list variables, will be inserted as `seq[V]`
        #      [ This part will consume as]
        #      [ as much functor arguments]
        #      [ as possible.             ]

        for cond in conds:
          echo cond.lispRepr()

        if elsebody.isSome():
          echo "Has `else`"

  ifTest:
    if 12 == 22:
      echo "123"
    elif false:
      echo "123"
    else:
      echo "123123"

    if 20 == 29:
      echo "123"
#+end_src

#+RESULTS:
: (Infix (Ident "==") (IntLit 12) (IntLit 22))
: (Ident "false")
: Has `else`
: (Infix (Ident "==") (IntLit 20) (IntLit 29))


** AST templating

** Rewriting


* Development

# TODO build documentation and upload it on github-pages.

Some things are informally described in [[file:devnotes.org]], most of the
functions and types are documented in the source code. If you have any
additional questions feel free to join my [[https://discord.gg/ZnBB4E][discord server]] and ask
questions there.
